#+title: Doom Emacs configuration

* Appearance
** Text
Set the desired font for Doom. The line height originates from the recommended settings from [[https://www.jetbrains.com/lp/mono/][the JetBrains Mono page]].

#+begin_src emacs-lisp
(setq doom-font (font-spec :family "JetBrainsMono Nerd Font" :size 12.0 :weight 'medium)
     doom-variable-pitch-font (font-spec :family "SF Pro Display" :size 13.0 :weight 'medium)
     line-spacing 1.11)
#+end_src

*** Custom fonts
**** Org-mode
Catppuccin makes the heading rainbow-coloured for some reason. It also sets a few other fonts to a purplish shade of white, which doesn't work as well with OLEDPuccin. Set them all back to white instead.
#+begin_src emacs-lisp
(after! org
  (custom-set-faces!
              '(org-level-1 :foreground "#ffffff" :height 1.4 :weight bold)
              '(org-level-2 :foreground "#ffffff" :height 1.2 :weight bold)
              '(org-level-3 :foreground "#ffffff" :height 1.1 :weight bold)
              '(org-level-4 :foreground "#ffffff" :height 1.0 :weight bold)
              '(org-level-5 :foreground "#ffffff" :height 0.9 :weight bold)
              '(org-document-title :height 2.0 :foreground "#ffffff" :weight heavy)
              '(org-time-grid :foreground "#ffffff")))
#+end_src

Set the colour for Org-mode blocks' beginning and ending lines to a lighter grey, to create a visual distinction that indicates where these blocks begin and end. This is visually bothersome if Org-modern fringes are enabled, however, so disable it if it is turned on.
#+begin_src emacs-lisp
(after! org
  (custom-set-faces!
    '(org-block :background "#000000")
              '(org-block-begin-line :background "#000000" :foregorund "#eeeeee")
              '(org-block-end-line :background "#000000" :foregorund "#eeeeee")))
#+end_src

** Modeline
*** Height
Increase Doom modeline's height from its default value of =25=.
#+begin_src emacs-lisp
(setq doom-modeline-height 40)
#+end_src

*** Width
#+begin_src emacs-lisp
(setq doom-modeline-bar-width 4)
#+end_src

** Transparency
#+begin_src emacs-lisp
(set-frame-parameter nil 'alpha-background 75)
(add-to-list 'default-frame-alist '(alpha-background . 75))
#+end_src

** Catppuccin theme
Catppuccin is a nice coloursheme, but the default background colour feels too jarring. I reckon OLEDPuccin would make for a more sleek appearance.

#+begin_src emacs-lisp
(setq doom-theme 'catppuccin)
(load-theme 'catppuccin t t)
(catppuccin-set-color 'base "#000000")
(catppuccin-set-color 'mantle "#0f0f0f")
(catppuccin-set-color 'crust "#1f1f1f")
(catppuccin-set-color 'text "#ffffff")
(catppuccin-reload)
#+end_src

** Line numbering
Set the line numbering to =relative= for easy Vim motions.

#+begin_src emacs-lisp
(setq display-line-numbers-type 'relative)
#+end_src

** Mixed pitch
#+begin_src emacs-lisp
(use-package mixed-pitch
  :hook
  ;; You might want to enable it only in org-mode or both text-mode and org-mode
  ((org-mode) . mixed-pitch-mode)
  :config
  (setq mixed-pitch-fixed-pitch-faces
        (append mixed-pitch-fixed-pitch-faces
                '(org-table
                  org-code
                  org-block
                  org-block-begin-line
                  org-block-end-line
                  org-meta-line
                  org-document-info-keyword
                  org-tag
                  org-time-grid
                  org-todo
                  org-done
                  org-agenda-date
                  org-date
                  org-drawer
                  org-modern-tag
                  org-modern-done
                  org-modern-label
                  org-scheduled
                  org-scheduled-today
                  neo-file-link-face
                  org-scheduled-previously)))
  (add-hook 'mixed-pitch-mode-hook #'solaire-mode-reset))
#+end_src

** Dashboard
Customise the ASCII art on the Doom dashboard. This one originates from NVChad, I believe.

#+begin_src emacs-lisp
(defun dysthesis/dashboard-setup ()
  (let* ((banner '("                                   "
	           "                                   "
	           "                                   "
	           "   ⣴⣶⣤⡤⠦⣤⣀⣤⠆     ⣈⣭⣿⣶⣿⣦⣼⣆          "
	           "    ⠉⠻⢿⣿⠿⣿⣿⣶⣦⠤⠄⡠⢾⣿⣿⡿⠋⠉⠉⠻⣿⣿⡛⣦       "
	           "          ⠈⢿⣿⣟⠦ ⣾⣿⣿⣷    ⠻⠿⢿⣿⣧⣄     "
	           "           ⣸⣿⣿⢧ ⢻⠻⣿⣿⣷⣄⣀⠄⠢⣀⡀⠈⠙⠿⠄    "
	           "          ⢠⣿⣿⣿⠈    ⣻⣿⣿⣿⣿⣿⣿⣿⣛⣳⣤⣀⣀   "
	           "   ⢠⣧⣶⣥⡤⢄ ⣸⣿⣿⠘  ⢀⣴⣿⣿⡿⠛⣿⣿⣧⠈⢿⠿⠟⠛⠻⠿⠄  "
	           "  ⣰⣿⣿⠛⠻⣿⣿⡦⢹⣿⣷   ⢊⣿⣿⡏  ⢸⣿⣿⡇ ⢀⣠⣄⣾⠄   "
	           " ⣠⣿⠿⠛ ⢀⣿⣿⣷⠘⢿⣿⣦⡀ ⢸⢿⣿⣿⣄ ⣸⣿⣿⡇⣪⣿⡿⠿⣿⣷⡄  "
	           " ⠙⠃   ⣼⣿⡟  ⠈⠻⣿⣿⣦⣌⡇⠻⣿⣿⣷⣿⣿⣿ ⣿⣿⡇ ⠛⠻⢷⣄ "
	           "      ⢻⣿⣿⣄   ⠈⠻⣿⣿⣿⣷⣿⣿⣿⣿⣿⡟ ⠫⢿⣿⡆     "
	           "       ⠻⣿⣿⣿⣿⣶⣶⣾⣿⣿⣿⣿⣿⣿⣿⣿⡟⢀⣀⣤⣾⡿⠃     "
	           "                                   "))
         (longest-line (apply #'max (mapcar #'length banner))))
    (put-text-property
     (point)
     (dolist (line banner (point))
       (insert (+doom-dashboard--center
                +doom-dashboard--width
                (concat line (make-string (max 0 (- longest-line (length line))) 32)))
               "\n"))
     'face 'doom-dashboard-banner)))

(setq +doom-dashboard-ascii-banner-fn #'dysthesis/dashboard-setup)
#+end_src

* Org-mode
Tell Emacs where our Org-mode documents are stored.
#+begin_src emacs-lisp
(setq org-directory "~/Org/")
#+end_src

The default three-dots (=...=) icons doesn't really look that great, so change it to an arrow symbol instead.
#+begin_src emacs-lisp
(after! org
  (setq org-ellipsis " ↪"))
#+end_src

Show entities as UTF-8 characters.
#+begin_src emacs-lisp
(setq org-pretty-entities t)
#+end_src

Start an Org file with all headers collapsed.
#+begin_src emacs-lisp
(setq org-startup-folded t)
#+end_src

** Archiving
Tell Emacs where entries should be archived to.
#+begin_src emacs-lisp
(setq org-archive-location "~/Org/archive.org::* From =%s=")
#+end_src

Create a macro for archiving all completed tasks.
#+begin_src emacs-lisp
(defun dysthesis/org-archive-done-tasks ()
  "Archive all done tasks."
  (interactive)
  (org-map-entries 'org-archive-subtree "/DONE" 'file))
#+end_src

** Refiling
Refiling means moving an Org-mode entry from one file to another. This is useful for quickly capturing entries to an inbox file, allowing for them to be organised later rather than now.

Tell Emacs which files Org-mode entries can be refiled to. This is used in conjunction with the GTD module.
#+begin_src emacs-lisp
(after! org
  (setq org-refile-targets '(("~/Org/GTD/gtd.org" :maxlevel . 2)
                           ("~/Org/GTD/someday.org" :level . 2)
                           ("~/Org/GTD/tickler.org" :maxlevel . 2)
                           ("~/Org/GTD/routine.org" :maxlevel . 2)
                           ("~/Org/GTD/reading.org" :maxlevel . 2))))
#+end_src

** Org-agenda
This (as well as Org-babel, of course) is perhaps the key feature of Org-mode that truly makes it worth the jump from, say, Obsidian. Markdown was not designed for task management, but Org is.

*** Basic setup
Configure a few basic variables for Org-agenda. This must be wrapped inside an =(after! org-agenda)= block to ensure that it does not get overwritten by Doom's default.

#+begin_src emacs-lisp :noweb yes
(after! org-agenda
  <<agenda-starts-today>>
  <<agenda-hide-completed-tasks>>
  <<agenda-show-deadlines>>
  <<agenda-hide-block-separator>>)
#+end_src

**** Do not show past dates in the time grid
By default, Org-agenda displays the past three days on the time-grid, as well as the next three days. The agenda is for planning, not for reflection and whatnot (at least, I don't use it that way). Therefore, set it to only display future dates.

#+name:agenda-starts-today
#+begin_src emacs-lisp :tangle no :noweb yes
(setq org-agenda-start-day "0d")
#+end_src

Here, =0d= means that Org-agenda will start the time-grid from today. To tell Org-agenda to start from yesterday, for example, set it to =-1d=, or set it to =1d= to start from tomorrow.

**** Do not show tasks if completed
By default, Org-agenda displays tasks even if they are completed. It is unnecessary, therefore, it should be disabled

#+name: agenda-hide-completed-tasks
#+begin_src emacs-lisp :tangle no :noweb yes
(setq org-agenda-skip-scheduled-if-done t
      org-agenda-skip-deadline-if-done t)
#+end_src

**** Show deadlines
I reckon this should be on by default, I have no idea why it isn't. It is important to be able to see deadlines of tasks in the agenda view, therefore, enable it.

#+name: agenda-show-deadlines
#+begin_src emacs-lisp :tangle no :noweb yes
(setq org-agenda-include-deadlines t)
#+end_src

**** Hide block separators
Block separators tend to be nothing more than visual clutter for me, therefore, disable it.

#+name:agenda-hide-block-separator
#+begin_src emacs-lisp :tangle no :noweb yes
(setq org-agenda-block-separator nil)
#+end_src

*** Agenda files
Set all Org files under =~/Org/GTD= as Org-agenda files.

#+begin_src emacs-lisp
(after! org
  (setq org-agenda-files (directory-files-recursively "~/Org/GTD/" "\\.org$")))
#+end_src

*** Keywords
Set the Org-agenda keyword sequence.

#+begin_src emacs-lisp
(after! org
  (setq org-todo-keywords
        '((sequence "TODO(t)" "NEXT(n)" "WAIT(w)" "PROG(p)" "|" "DONE(d)" "|" "CANCEL(c)"))))
#+end_src

*** Sorting strategy
Define how Org-agenda should sort agenda entries. Here, it should sort based on the following, listed in order of importance:

1. *Urgency*, in a descending order. Urgency is a score calculated by Emacs based on the priority and deadline of a task.
2. *Deadline,* in an ascending order (from earliest to latest).
3. *Priority,* in a descending order (from the most to least important).
4. *Effort,* in an ascending order (from lowest to highest effort).

   #+begin_src emacs-lisp
(after! org
  (setq org-agenda-sorting-strategy
        '((urgency-up deadline-up priority-down effort-up))))
   #+end_src

*** Habit visualiser
Add a diagram for visualising Org-agenda habits.

#+begin_src emacs-lisp
(add-to-list 'org-modules 'org-habit t)
#+end_src

*** GTD functions
Stolen from [[https://github.com/jethrokuan/dots/blob/master/.doom.d/config.el][Jethro Kuan's Emacs configuration]], and slightly modified. This section of the configuration is responsible for managing inbox items in an Org-agenda view. When you press =r= in an agenda view, it will start finding any inbox items and iterate through it, prompting you for tags, categories, timestamp, and refile targets. If the tag =someday= is *not* present, it will ask for a scheduled or deadline time too.

How this version differs from Jethro's original version:
- For some reason, the original =mark-inbox-todos= does not work, because =org-agenda-bulk-mark-regexp= does not behave as expected. Therefore, we iterate through each TODO item in the agenda and get their categories instead.

**** Bulk select inbox tasks
First, create a function which searches for all tasks with the category =inbox=. This includes any tasks from any files called =inbox.org=, since apparently, the file name is the default category. This function will loop through all entries in the current agenda view, and apply a regex to validate the task's category, marking any called 'inbox'.

#+begin_src emacs-lisp
(defun dysthesis/mark-inbox-todos ()
  "Mark entries in the agenda whose category is 'inbox' for future bulk action."
  (let ((entries-marked 0)
        (regexp "inbox")  ; Set the search term to 'inbox'
        category-at-point)
    (save-excursion
      (goto-char (point-min))
      (goto-char (next-single-property-change (point) 'org-hd-marker))
      (while (re-search-forward regexp nil t)
        (setq category-at-point (get-text-property (match-beginning 0) 'org-category))
        (if (or (get-char-property (point) 'invisible)
                (not category-at-point))  ; Skip if category is nil
            (beginning-of-line 2)
          (when (string-match-p regexp category-at-point)
            (setq entries-marked (1+ entries-marked))
            (call-interactively 'org-agenda-bulk-mark))))
      (unless entries-marked
        (message "No entry matching 'inbox'.")))))
#+end_src

**** Process a single entry
This function interactively sets the tags, priority, and category for a single task, and proceeds to refile it.

#+begin_src emacs-lisp
(defun dysthesis/org-agenda-process-inbox-item ()
  "Process a single item in the org-agenda."
  (org-with-wide-buffer
   (org-agenda-set-tags)
   (org-agenda-priority)

   ;; Get the marker for the current headline
   (let* ((hdmarker (org-get-at-bol 'org-hd-marker))
          (category (completing-read "Category: " '("University" "Home" "Tinkering" "Read"))))
     ;; Switch to the buffer of the actual Org file
     (with-current-buffer (marker-buffer hdmarker)
       (goto-char (marker-position hdmarker))
       ;; Set the category property
       (org-set-property "CATEGORY" category))

   (call-interactively 'dysthesis/my-org-agenda-set-effort)
   (org-agenda-refile nil nil t))))
#+end_src

***** Helper function to set the effort
#+begin_src emacs-lisp
(defvar dysthesis/org-current-effort "1:00"
  "Current effort for agenda items.")
(defun dysthesis/my-org-agenda-set-effort (effort)
  "Set the effort property for the current headline."
  (interactive
   (list (read-string (format "EFFORT [%s]: " dysthesis/org-current-effort) nil nil dysthesis/org-current-effort)))
  (setq dysthesis/org-current-effort effort)
  (org-agenda-check-no-diary)
  (let* ((hdmarker (or (org-get-at-bol 'org-hd-marker)
                       (org-agenda-error)))
         (buffer (marker-buffer hdmarker))
         (pos (marker-position hdmarker))
         (inhibit-read-only t)
         newhead)
    (org-with-remote-undo buffer
      (with-current-buffer buffer
        (widen)
        (goto-char pos)
        (org-show-context 'agenda)
        (funcall-interactively 'org-set-effort nil dysthesis/org-current-effort)
        (end-of-line 1)
        (setq newhead (org-get-heading)))
      (org-agenda-change-all-lines newhead hdmarker))))
#+end_src

**** Process multiple entries
This function applies the =dysthesis/org-agenda-process-inbox-item= function on every item that is bulk-marked, and the unmarks them.

#+begin_src emacs-lisp
(defun dysthesis/bulk-process-entries ()
  (let ())
  (if (not (null org-agenda-bulk-marked-entries))
      (let ((entries (reverse org-agenda-bulk-marked-entries))
            (processed 0)
            (skipped 0))
        (dolist (e entries)
          (let ((pos (text-property-any (point-min) (point-max) 'org-hd-marker e)))
            (if (not pos)
                (progn (message "Skipping removed entry at %s" e)
                       (cl-incf skipped))
              (goto-char pos)
              (let (org-loop-over-headlines-in-active-region) (funcall 'dysthesis/org-agenda-process-inbox-item))
              ;; `post-command-hook' is not run yet.  We make sure any
              ;; pending log note is processed.
              (when (or (memq 'org-add-log-note (default-value 'post-command-hook))
                        (memq 'org-add-log-note post-command-hook))
                (org-add-log-note))
              (cl-incf processed))))
        (org-agenda-redo)
        (unless org-agenda-persistent-marks (org-agenda-bulk-unmark-all))
        (message "Acted on %d entries%s%s"
                 processed
                 (if (= skipped 0)
                     ""
                   (format ", skipped %d (disappeared before their turn)"
                           skipped))
                 (if (not org-agenda-persistent-marks) "" " (kept marked)")))))
#+end_src


**** Process the entire inbox
Combine the previously defined functions to process the entire inbox.

#+begin_src emacs-lisp
(defun dysthesis/org-process-inbox ()
  "Called in org-agenda-mode, processes all inbox items."
  (interactive)
  (dysthesis/mark-inbox-todos)
  (dysthesis/bulk-process-entries))
#+end_src

**** Miscellaneous helper functions
#+begin_src emacs-lisp
(setq org-log-done 'time
      org-log-into-drawer t
      org-log-state-notes-insert-after-drawers nil)
(defun log-todo-next-creation-date (&rest ignore)
  "Log NEXT creation time in the property drawer under the key 'ACTIVATED'"
  (when (and (string= (org-get-todo-state) "NEXT")
             (not (org-entry-get nil "ACTIVATED")))
    (org-entry-put nil "ACTIVATED" (format-time-string "[%Y-%m-%d]"))))
(add-hook 'org-after-todo-state-change-hook #'log-todo-next-creation-date)
#+end_src

*** Keybinding
Make it easier to perform agenda-related operations.

First, we define some functions (macros).
#+begin_src emacs-lisp
(defun dysthesis/org-inbox-capture ()
  (interactive)
  "Capture a task in agenda mode."
  (org-capture nil "i"))
(defun dysthesis/org-capture-todo ()
  (interactive)
  (org-capture nil "tt"))
(defun dysthesis/org-capture-todo-with-deadline ()
  (interactive)
  (org-capture nil "td"))
(defun dysthesis/org-capture-todo-with-schedule ()
  (interactive)
  (org-capture nil "ts"))
#+end_src

Then map them.
#+begin_src emacs-lisp
(map! :map org-agenda-mode-map
      "i" #'org-agenda-clock-in
      "r" #'dysthesis/org-process-inbox
      "R" #'org-agenda-refile)


(bind-key "C-c t" #'dysthesis/org-capture-todo)
(bind-key "C-c d" #'dysthesis/org-capture-todo-with-deadline)
(bind-key "C-c s" #'dysthesis/org-capture-todo-with-schedule)
#+end_src

*** Colourised calendar view
Colour the calendar view based on the number of tasks scheduled for that day. The more tasks there are, the darker the shade of grey. Note that this function is relatively resource intensive, and setting too many files for =org-files= will cause the calendar buffer (which appears when scheduling tasks) to be very slow. It is advisable to use a small number of large files rather than a large number of small files for this. This is taken from [[https://emacs.stackexchange.com/questions/58634/color-calendar-day-according-to-number-of-event-in-org-agenda][Nicolas Rougier's post on StackExchange.]]

#+begin_src emacs-lisp
(defface busy-1  '((t :foreground "black" :background "#eceff1")) "")
(defface busy-2  '((t :foreground "black" :background "#cfd8dc")) "")
(defface busy-3  '((t :foreground "black" :background "#b0bec5")) "")
(defface busy-4  '((t :foreground "black" :background "#90a4ae")) "")
(defface busy-5  '((t :foreground "white" :background "#78909c")) "")
(defface busy-6  '((t :foreground "white" :background "#607d8b")) "")
(defface busy-7  '((t :foreground "white" :background "#546e7a")) "")
(defface busy-8  '((t :foreground "white" :background "#455a64")) "")
(defface busy-9  '((t :foreground "white" :background "#37474f")) "")
(defface busy-10 '((t :foreground "white" :background "#263238")) "")
(defadvice calendar-generate-month
    (after highlight-weekend-days (month year indent) activate)
  "Highlight weekend days"
  (dotimes (i 31)
    (let* ((org-files (directory-files-recursively "~/Org/GTD" "\\.org$"))
           (date (list month (1+ i) year))
           (count 0))
      (dolist (file org-files)
        (setq count (+ count (length (org-agenda-get-day-entries file date)))))
      (cond ((= count 0) ())
            ((= count 1) (calendar-mark-visible-date date 'busy-1))
            ((= count 2) (calendar-mark-visible-date date 'busy-2))
            ((= count 3) (calendar-mark-visible-date date 'busy-3))
            ((= count 4) (calendar-mark-visible-date date 'busy-4))
            ((= count 5) (calendar-mark-visible-date date 'busy-5))
            ((= count 6) (calendar-mark-visible-date date 'busy-6))
            ((= count 7) (calendar-mark-visible-date date 'busy-7))
            ((= count 8) (calendar-mark-visible-date date 'busy-8))
            ((= count 9) (calendar-mark-visible-date date 'busy-9))
            (t  (calendar-mark-visible-date date 'busy-10)))
      )))
#+end_src

*** Org-super-agenda
**** Keep the sorted order
Do not re-sort the agenda entries when grouping them. The sorting strategy was defined earlier, and it should be kept that way.

#+begin_src emacs-lisp
(after! org-agenda
  (setq org-super-agenda-keep-order t))
#+end_src

**** Agenda views
#+begin_src emacs-lisp
(after! org-agenda
  (let ((inhibit-message t))
    (org-super-agenda-mode)))

(setq org-agenda-custom-commands
      '(("o" "Overview"
         ((agenda "" ((org-agenda-span 'day)
                      (org-super-agenda-groups
                       '((:name "Today"
                          :time-grid t
                          :deadline today
                          :scheduled today
                          :order 0)
                         (:habit t
                          :order 1)
                         (:name "Overdue"
                          :deadline past
                          :scheduled past
                          :order 2)
                         (:name "Upcoming"
                          :and (:deadline future
                                :priority>= "B")
                          :and (:scheduled future
                                :priority>= "B")
                          :order 3)
                         (:discard (:anything t))))))
          (alltodo "" ((org-agenda-overriding-header "")
                       (org-super-agenda-groups
                        '((:name "Ongoing"
                           :todo "PROG"
                           :order 0)
                          (:name "Up next"
                           :todo "NEXT"
                           :order 1)
                          (:name "Waiting"
                           :todo "WAIT"
                           :order 2)
                          (:name "Important"
                           :priority "A"
                           :order 3)
                          (:name "Inbox"
                           :file-path "inbox"
                           :order 4)
                          (:name "University"
                           :category "University"
                           :tag ("university"
                                 "uni"
                                 "assignment"
                                 "exam")
                           :order 5)
                          (:name "Tinkering"
                           :category "Tinkering"
                           :tag ("nix"
                                 "nixos"
                                 "gentoo"
                                 "emacs"
                                 "tinker")
                           :order 6)
                          (:name "Reading list"
                           :category "Read"
                           :tag "read"
                           :order 6)))))))))
#+end_src

**** Keybinds
#+begin_src emacs-lisp
(defun dysthesis/agenda ()
  (interactive)
  (org-agenda nil "o"))

(use-package! org-agenda
  :init
  (map! "C-c a" #'dysthesis/agenda))
#+end_src


** Capture templates
The DOCT (Declarative Org Capture Templates) package provides a better way to configure capture templates. In particular, it allows for the configuration of capture templates as a 'child' of another, inheriting its traits.
#+begin_src emacs-lisp
(use-package! doct
  :commands doct)
#+end_src
The above code initialises DOCT. It is now possible to invoke the command =doct= to define capture templates.

#+begin_src emacs-lisp
(after! org
  (setq org-capture-templates
        (doct '((" Todo"
                 :keys "t"
                 :prepend t
                 :file "GTD/inbox.org"
                 :headline "Tasks"
                 :type entry
                 :template ("* TODO %? %{extra}")
                 :children ((" General"
                             :keys "t"
                             :extra "")
                            ("󰈸 With deadline"
                             :keys "d"
                             :extra "\nDEADLINE: %^{Deadline:}t")
                            ("󰥔 With schedule"
                             :keys "s"
                             :extra "\nSCHEDULED: %^{Start time:}t")))
                ("Bookmark"
                 :keys "b"
                 :prepend t
                 :file "bookmarks.org"
                 :type entry
                 :template "* TODO [[%:link][%:description]] :bookmark:\n\n"
                 :immediate-finish t)))))
#+end_src

** Org-modern
An alternative to this package is Doom's built-in =+pretty= module for Org. It doesn't do enough for my tastes, however, while Org-modern does. Most of the code in this section are simply taken from Org-modern's README, as well as [[https://tecosaur.github.io/emacs-config/config.html][Tecosaur's Doom Emacs configuration]].

*** Initialisation
These functions are not part of Org-modern, but complements it quite well.
#+begin_src emacs-lisp
(package-initialize)
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
(dolist (face '(window-divider
                window-divider-first-pixel
                window-divider-last-pixel))
  (face-spec-reset-face face)
  (set-face-foreground face (face-attribute 'default :background)))
(set-face-background 'fringe (face-attribute 'default :background))
#+end_src

*** Hide emphasis markers
By default, Org-mode always displays emphasis markers and other such elements, which may become bothersome. It is possible to entirely disable them, such as with =org-hide-emphasis-markers=, however, that may also eventually lead to confusion during editing. Therefore, use the =org-appear= package to automatically toggle the visibility of these elements when hovered over by the cursor.

#+begin_src emacs-lisp
(setq org-hide-emphasis-markers t)
#+end_src

*** Prettier bullets
The default Org-mode bullets don't look nice at all. Org-modern allows for the substitution of these with different symbols.

#+begin_src emacs-lisp
(setq  org-modern-list
       '((42 . "•")
         (43 . "◈")
         (45 . "➤")))
#+end_src

[[https://www.youtube.com/watch?v=vVPT0JT1dOw][The numbers, mason, what do they mean?!]]

- =45= is the dash (=-=) bullet,
- =43= is the plus (=+=) bullet,
- and =42= is the asterisk (=*=) bullet.

*** Substitute block names with symbols
Org-modern allows for the substitution of block names within Org-mode, such as =src=, =quote=, etc., with symbols. This is more visually pleasing.

#+begin_src emacs-lisp
(setq org-modern-block-name
      '((t . t)
        ("src" "»" "«")
        ("example" "»–" "–«")
        ("quote" "" "")
        ("export" "⏩" "⏪")))
#+end_src

*** Block fringe
Add a fringe to the left side of Org-mode blocks for stylistic purposes. The integer represents the margin between the fringe and the text.

#+begin_src emacs-lisp
(setq org-modern-block-fringe 6)
#+end_src

Use the =org-modern-indent= package to fix block fringes when indented.
#+begin_src emacs-lisp
(use-package org-modern-indent
  :config ; add late to hook
  (add-hook 'org-mode-hook #'org-modern-indent-mode 90))
#+end_src

*** Substitute keywords with symbols
It is also possible to substitute entire keywords instead of just block names. This is useful for making elements such as document metadatas (=#+title=, =#+property=, etc.) more visually pleasing.

#+begin_src emacs-lisp
(setq org-modern-keyword
 '((t . t)
   ("title" . "𝙏 ")
   ("filetags" . "󰓹 ")
   ("auto_tangle" . "󱋿 ")
   ("subtitle" . "𝙩 ")
   ("author" . "𝘼 ")
   ("email" . #(" " 0 1 (display (raise -0.14))))
   ("date" . "𝘿 ")
   ("property" . "☸ ")
   ("options" . "⌥ ")
   ("startup" . "⏻ ")
   ("macro" . "𝓜 ")
   ("bind" . #(" " 0 1 (display (raise -0.1))))
   ("bibliography" . " ")
   ("print_bibliography" . #(" " 0 1 (display (raise -0.1))))
   ("cite_export" . "⮭ ")
   ("print_glossary" . #("ᴬᶻ " 0 1 (display (raise -0.1))))
   ("glossary_sources" . #(" " 0 1 (display (raise -0.14))))
   ("include" . "⇤ ")
   ("setupfile" . "⇚ ")
   ("html_head" . "🅷 ")
   ("html" . "🅗 ")
   ("latex_class" . "🄻 ")
   ("latex_class_options" . #("🄻 " 1 2 (display (raise -0.14))))
   ("latex_header" . "🅻 ")
   ("latex_header_extra" . "🅻⁺ ")
   ("latex" . "🅛 ")
   ("beamer_theme" . "🄱 ")
   ("beamer_color_theme" . #("🄱 " 1 2 (display (raise -0.12))))
   ("beamer_font_theme" . "🄱𝐀 ")
   ("beamer_header" . "🅱 ")
   ("beamer" . "🅑 ")
   ("attr_latex" . "🄛 ")
   ("attr_html" . "🄗 ")
   ("attr_org" . "⒪ ")
   ("call" . #(" " 0 1 (display (raise -0.15))))
   ("name" . "⁍ ")
   ("header" . "› ")
   ("caption" . "☰ ")
   ("results" . "🠶")))
#+end_src
*** Org-agenda styling
Make the time-grid on Org-agenda views look nicer.
#+begin_src emacs-lisp
(setq org-agenda-tags-column 0
      org-agenda-block-separator ?─
      org-agenda-time-grid
      '((daily today require-timed)
        (800 1000 1200 1400 1600 1800 2000)
        " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄")
      org-agenda-current-time-string
      "⭠ now ─────────────────────────────────────────────────")
#+end_src

Give colour to TODO faces.

#+begin_src emacs-lisp
(setq org-modern-todo-faces
 '(("WAIT"
    :inverse-video t
    :inherit +org-todo-onhold)
   ("NEXT"
    :inverse-video t
    :foreground "#89b4fa")
   ("PROG"
    :inverse-video t
    :foreground "#a6e3a1")
   ("TODO"
    :inverse-video t
    :foreground "#fab387")))
#+end_src

*** Always-on Org-modern mode
Invoke the =global-org-modern-mode= to always enable this mode.

#+begin_src emacs-lisp
(global-org-modern-mode)
#+end_src

** Org-roam
*** General
Tell Org-roam where it should look for files. Here, =file-truename= is used to resolve symbolic links if any. It is not harmful to have it here even if symbolic links are not used.
#+begin_src emacs-lisp
(setq org-roam-directory (file-truename "~/Org/Roam"))
#+end_src

Start up Org-roam.
#+begin_src emacs-lisp :noweb yes
(use-package org-roam
  :ensure t
  :init
  (setq org-roam-v2-ack t)
  :custom
  <<org-roam-dailies>>
  :bind
  <<org-roam-keybinds>>
  :bind-keymap
  <<org-roam-dailies-keybinds>>
  :config
  <<org-roam-database-autosync>>
  <<org-roam-ensure-dailies>>
  <<org-roam-popup-rules>>
  <<org-roam-capture-templates>>)
#+end_src

*** Dailies
Org-roam-dailies is a part of Org-roam that allows for journalling. Define the capture template and where to store its files (relative to the Org-roam directory path).

#+name: org-roam-dailies
#+begin_src emacs-lisp :tangle no :noweb yes
(org-roam-dailies-capture-templates
    '(("d" "default" entry "* %<%H:%M> %?"
       :if-new (file+head "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n"))))
(org-roam-dailies-directory "Daily/")
#+end_src

Tell Org-roam to ensure that the dailies module is loaded on startup.
#+name: org-roam-ensure-dailies
#+begin_src emacs-lisp :tangle no :noweb yes
(require 'org-roam-dailies)
#+end_src

*** Keybinding
Define some basic Org-roam keybindings.
#+name:org-roam-keybinds
#+begin_src emacs-lisp :noweb yes :tangle no
(("C-c n l" . org-roam-buffer-toggle)
     ("C-c n f" . org-roam-node-find)
     ("C-c n i" . org-roam-node-insert)
     ("C-c i" . org-roam-node-insert)
     ("C-c n q" . org-roam-node-insert-immediate)
     ("C-c n t" . org-roam-tag-add)
     ("C-c n c" . org-roam-capture)
     ("C-c n a" . org-roam-alias-add)
     :map org-mode-map
     ("C-M-i"    . completion-at-point)
     :map org-roam-dailies-map
     ("y" . org-roam-dailies-capture-yesterday)
     ("t" . org-roam-dailies-capture-tomorrow))
#+end_src

Also define some basic Org-roam-dailies keybindings.
#+name: org-roam-dailies-keybinds
#+begin_src emacs-lisp :tangle no :noweb yes
("C-c n d" . org-roam-dailies-map)
#+end_src

*** Autosync database
Automatically keep the Org-roam database up to dateto maintain cache consistency.
#+name:org-roam-database-autosync
#+begin_src emacs-lisp :noweb yes :tangle no
(org-roam-db-autosync-mode)
#+end_src

*** Popup rules
Define some rules for the popup windows for Org-roam.
#+name:org-roam-popup-rules
#+begin_src emacs-lisp :noweb yes :tangle no
(set-popup-rules!
`((,(regexp-quote org-roam-buffer) ; persistent org-roam buffer
   :side right :width .33 :height .5 :ttl nil :modeline nil :quit nil :slot 1)
  ("^\\*org-roam: " ; node dedicated org-roam buffer
   :side right :width .33 :height .5 :ttl nil :modeline nil :quit nil :slot 2)))
#+end_src

*** Capture templates
Define templates for Org-roam capture. This is separate from the default Org-mode capture templates, and cannot be defined with DOCT, unfortunately.

#+name: org-roam-capture-templates
#+begin_src emacs-lisp :noweb yes :tangle no
(setq org-roam-capture-templates
      '(("d" " Default" plain
         "%?"
         :if-new (file+head "${slug}.org"
                            "#+title: ${title}\n#+filetags: :new:\n#+STARTUP: latexpreview")
         :immediate-finish t
         :unnarrowed t)
        ("i" "󰆼 Index note" plain
         "%?"
         :if-new (file+head "${slug}.org"
                            "#+title: ${title}\n#+filetags: :new:index:")
         :immediate-finish t
         :unarrowed t)
        ("e" "󰖟 Elfeed" plain
         "%?"
         :target (file+head "Elfeed/${slug}.org"
                            "#+title: ${title}\n#+filetags: :new:article:rss:\n#+STARTUP: latexpreview"
                            ;;"#+filetags: :article:rss:\n"
                            )
         :unnarrowed t)
        ("l" "󰙨 Literature note" plain
         "%?"
         :target
         (file+head
          "%(expand-file-name (or citar-org-roam-subdir \"\") org-roam-directory)/Literature/${citar-citekey}.org"
          "#+title: ${note-title}.\n#+filetags: :new:\n#+created: %U\n#+last_modified: %U\n#+STARTUP: latexpreview\n\n* Annotations\n:PROPERTIES:\n:Custom_ID: ${citar-citekey}\n:NOTER_DOCUMENT: ${citar-file}\n:NOTER_PAGE: \n:END:\n\n")
         :unnarrowed t)
        ("d" " Idea" plain "%?"
         :if-new
         (file+head "${slug}.org" "#+title: ${title}\n#+filetags: :idea:new:\n#+STARTUP: latexpreview\n")
         :immediate-finish t
         :unnarrowed t)))
#+end_src

*** Quick capture
Create a function to quickly insert a link to a nonexistent note without necessarily capturing into it immediately.

#+begin_src emacs-lisp
(defun org-roam-node-insert-immediate (arg &rest args)
  (interactive "P")
  (let ((args (cons arg args))
        (org-roam-capture-templates (list (append (car org-roam-capture-templates)
                                                  '(:immediate-finish t)))))
    (apply #'org-roam-node-insert args)))
#+end_src

*** Graph view
#+begin_src emacs-lisp
(use-package! websocket
    :after org-roam)

(use-package! org-roam-ui
  :after org ;; or :after org
  ;;         normally we'd recommend hooking orui after org-roam, but since org-roam does not have
  ;;         a hookable mode anymore, you're advised to pick something yourself
  ;;         if you don't care about startup time, use
  ;;  :hook (after-init . org-roam-ui-mode)
  :config
  (setq org-roam-ui-sync-theme t
        org-roam-ui-follow t
        org-roam-ui-update-on-save t
        org-roam-ui-open-on-start t
        org-roam-ui-custom-theme
        '((bg-alt . "#0f0f0f")
          (bg . "#000000")
          (fg . "#ffffff")
          (fg-alt . "#cdd6f4")
          (red . "#f38ba8")
          (orange . "#fab387")
          (yellow ."#f9e2af")
          (green . "#a6e3a1")
          (cyan . "#94e2d5")
          (blue . "#89b4fa")
          (violet . "#8be9fd")
          (magenta . "#f5c2e7"))))
#+end_src

*** Document annotator
Org-noter allows for the annotation of PDFs, and EPUBs (with =nov.el=).

#+begin_src emacs-lisp
(use-package org-noter
  :after (:any org pdf-view)
  :config
  (setq
   ;; Please stop opening frames
   org-noter-always-create-frame nil
   ;; I want to see the whole file
   org-noter-hide-other nil
   ;; Everything is relative to the main notes file
   org-noter-notes-search-path (list org-directory)
   ))
#+end_src

*** LaTeX
Set up Org-fragtog to toggle LaTeX fragments when the cursor hovers in and out of it.
#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'org-fragtog-mode)
#+end_src

Make Org-mode LaTeX previews work better with black themes by forcibly setting the foreground colour to white.
#+begin_src emacs-lisp
(plist-put org-format-latex-options :foreground "White")
(plist-put org-format-latex-options :background nil)
#+end_src

Enable syntax highlighting for LaTeX fragments in the document.
#+begin_src emacs-lisp
(setq org-highlight-latex-and-related '(latex script entities))
#+end_src

Allow for previewing TikZ plots.
#+begin_src emacs-lisp
(add-to-list 'org-latex-packages-alist
             '("" "tikz" t))

(eval-after-load "preview"
  '(add-to-list 'preview-default-preamble "\\PreviewEnvironment{tikzpicture}" t))

(after! org
  (setq org-latex-create-formula-image-program 'dvisvgm))
#+end_src

*** Babel
Automatically tangle a literate document on save.
#+begin_src emacs-lisp
(use-package org-auto-tangle
  :defer t
  :hook (org-mode . org-auto-tangle-mode))
#+end_src

*** Citar integration
Use the =citar-org-roam= package to create citation notes in Org-roam.
#+begin_src emacs-lisp
(use-package citar-org-roam
  :after (citar org-roam)
  :config (citar-org-roam-mode))
(setq citar-org-roam-capture-template-key "l")
(setq citar-org-roam-note-title-template "${author} - ${title}")
#+end_src

**** Template fields
#+begin_src emacs-lisp
(setq citar-org-roam-template-fields
  '((:citar-title . ("title"))
    (:citar-author . ("author" "editor"))
    (:citar-date . ("date" "year" "issued"))
    (:citar-pages . ("pages"))
    (:citar-type . ("=type="))
    (:citar-file . ("file"))))
#+end_src


** Org-ref
#+begin_src emacs-lisp
(use-package! org-ref
    ;:after org-roam
    :config
    (setq
     org-ref-get-pdf-filename-function
      (lambda (key) (car (bibtex-completion-find-pdf key)))
     org-ref-default-bibliography (list "~/Org/Library.bib")
     ;;org-ref-bibliography-notes "~/Org/Roam/Literature/bibnotes.org"
     org-ref-pdf-directory "~/Documents/Library/files"
     org-ref-note-title-format "* %y - %t\n :PROPERTIES:\n  :Custom_ID: %k\n  :NOTER_DOCUMENT: %F\n :ROAM_KEY: cite:%k\n  :AUTHOR: %9a\n  :JOURNAL: %j\n  :YEAR: %y\n  :VOLUME: %v\n  :PAGES: %p\n  :DOI: %D\n  :URL: %U\n :END:\n\n"
     org-ref-notes-directory "~/Org/Roam/Literature"
     org-ref-notes-function 'orb-edit-notes))

(after! org-ref
(setq
 bibtex-completion-notes-path "~/Org/Roam/Literature/"
 bibtex-completion-bibliography "~/Org/Library.bib"
 bibtex-completion-library-path "~/Documents/Library/files/"
 bibtex-completion-pdf-field "file"
 bibtex-completion-notes-template-multiple-files
 (concat
  "#+TITLE: ${title}\n"
  "#+ROAM_KEY: cite:${=key=}\n"
  "* TODO Notes\n"
  ":PROPERTIES:\n"
  ":CUSTOM_ID: ${=key=}\n"
  ":NOTER_DOCUMENT: %(orb-process-file-field \"${=key=}\")\n"
  ":AUTHOR: ${author-abbrev}\n"
  ":JOURNAL: ${journaltitle}\n"
  ":DATE: ${date}\n"
  ":YEAR: ${year}\n"
  ":DOI: ${doi}\n"
  ":URL: ${url}\n"
  ":END:\n\n"
  )
 )
)
#+end_src

* EPUB Reading
The package =nov.el= provides support for opening EPUB documents in Emacs. Tell Emacs to enable =nov-mode= when an EPUB file is open.

#+begin_src emacs-lisp :noweb yes
(use-package! nov
  :mode ("\\.epub\\'" . nov-mode)
  :config
  <<novel-keymaps>>
  <<novel-title-on-doom-modeline>>
  <<novel-disable-rendering-title>>
  <<novel-setup>>)
#+end_src

** Keymaps
Define keymaps to be enabled when in =nov-mode.=
#+name: novel-keymaps
#+begin_src emacs-lisp :tangle no :noweb yes
(map! :map nov-mode-map
        :n "RET" #'nov-scroll-up)
#+end_src

** Display book title on Doom's modeline
#+name: novel-title-on-doom-modeline
#+begin_src emacs-lisp :tangle no :noweb yes
(defun doom-modeline-segment--nov-info ()
    (concat
     " "
     (propertize
      (cdr (assoc 'creator nov-metadata))
      'face 'doom-modeline-project-parent-dir)
     " "
     (cdr (assoc 'title nov-metadata))
     " "
     (propertize
      (format "%d/%d"
              (1+ nov-documents-index)
              (length nov-documents))
      'face 'doom-modeline-info)))
#+end_src

** Disable rendering title
#+name:novel-disable-rendering-title
#+begin_src emacs-lisp :tangle no :noweb yes
(advice-add 'nov-render :override #'ignore)
#+end_src

** Setup functon
Description created by =deepseek-coder-33b= (refactor this later):
#+begin_quote

1. Firstly, this function changes the default font face for variable pitch text to "Georgia Pro" at 1.4 size. Also, it sets the default font height to 1.3.

2. It then adjusts various display settings such as line spacing (0.2), number of lines considered in context on screen navigation (next-screen-context-lines is set to 4), and setting shr-use-colors nil which means colors will not be used in rendering the document.

3. It requires 'visual-fill-column, which allows text to be reflowed so it fits within a specified width, and sets some visual-fill-column related settings like whether the text should be centered or not (visual-fill-column-center-text is set true), visual-fill-column width (set to 81) and nov-text-width (set to 80).

4. It then enables the visual-fill-column mode, which uses 'visual-fill-column to reflow the text in the current buffer, thus ensuring that each line occupies the full window width.

5. It turns off hl-line mode, a minor mode that highlights the current line.

6. The function then re-renders the document with the new settings and adds lookup functionality for words via a dictionary (`+lookup/dictionary-definition`) to the list of definitions functions.

7. Finally, it customizes the mode-line format to display workspace name, window number, nov info, percent position, empty space and major mode in certain way according to certain conditions. It uses doom-modeline library for this customization.

In a nutshell, the function is setting up a specific kind of document viewer with certain aesthetics and functionalities customized to our preference.

#+end_quote

#+name:novel-setup
#+begin_src emacs-lisp :tangle no :noweb yes
(defun +nov-mode-setup ()
    "Tweak nov-mode to our liking."
    (face-remap-add-relative 'variable-pitch
                             :family "Georgia Pro"
                             :height 1.4)
    (face-remap-add-relative 'default :height 1.3)
    (setq-local line-spacing 0.2
                next-screen-context-lines 4
                shr-use-colors nil)
    (require 'visual-fill-column nil t)
    (setq-local visual-fill-column-center-text t
                visual-fill-column-width 81
                nov-text-width 80)
    (visual-fill-column-mode 1)
    (hl-line-mode -1)
    ;; Re-render with new display settings
    (nov-render-document)
    ;; Look up words with the dictionary.
    (add-to-list '+lookup-definition-functions #'+lookup/dictionary-definition)
    ;; Customise the mode-line to make it more minimal and relevant.
    (setq-local
     mode-line-format
     `((:eval
        (doom-modeline-segment--workspace-name))
       (:eval
        (doom-modeline-segment--window-number))
       (:eval
        (doom-modeline-segment--nov-info))
       ,(propertize
         " %P "
         'face 'doom-modeline-buffer-minor-mode)
       ,(propertize
         " "
         'face (if (doom-modeline--active) 'mode-line 'mode-line-inactive)
         'display `((space
                     :align-to
                     (- (+ right right-fringe right-margin)
                        ,(* (let ((width (doom-modeline--font-width)))
                              (or (and (= width 1) 1)
                                  (/ width (frame-char-width) 1.0)))
                            (string-width
                             (format-mode-line (cons "" '(:eval (doom-modeline-segment--major-mode))))))))))
       (:eval (doom-modeline-segment--major-mode)))))
(add-hook 'nov-mode-hook #'+nov-mode-setup)
#+end_src

* RSS
Emacs can become an RSS feed reader with the =elfeed= package.

- =elfeed-search= is the menu buffer that displays all the entries of your feed.
- =elfeed-show= is the buffer that displays the contents of an entry.

  Ensure that =elfeed-org= is installed, which should be the case if =(rss +org)= is specified in [[file:./init.el][init.el]].
#+begin_src emacs-lisp
(require 'elfeed-org)
#+end_src

=elfeed-org= allows the declaration of RSS feed URLs using an Org syntax, which is more legible and convenient than the Emacs Lisp syntax that =elfeed= would otherwise use. It also allows for feeds defined under a subheading with some tags to inherit these tags.

It is necessary to then declare to =elfeed-org= where it should find the list of feeds:
#+begin_src emacs-lisp
(setq rmh-elfeed-org-files (list "~/.config/doom/elfeed.org"))
#+end_src

Doom Emacs has its own default configurations of Elfeed. It is necessary, therefore, to invoke =(after! elfeed)= when writing our own configuration.
#+begin_src emacs-lisp :noweb yes
(after! elfeed
  (elfeed-org)
  (use-package! elfeed-link)
  <<elfeed-search-filter>>
  <<elfeed-search-define-print-entry-function>>
  <<elfeed-search-title-min-width>>
  <<elfeed-show-entry-switch>>
  <<elfeed-show-entry-delete>>
  <<elfeed-show-define-refresh-function>>
  <<elfeed-image-size>>
  <<elfeed-better-wrap-heading>>
  <<elfeed-show-refresh-function>>
  <<elfeed-search-print-entry-function>>)
#+end_src

** Filter
RSS entries can clog up the =elfeed-search= view after a while. Therefore, set the default filter to only show entries no older than two weeks and unread.

#+name:elfeed-search-filter
#+begin_src emacs-lisp :tangle no :noweb yes
(setq elfeed-search-filter "@2-week-ago +unread")
#+end_src

** Print entry function
This function instructs =elfeed-search= on how to display each entry. This includes the specification of aspects such as column width for each entry's properties (such as its source, tags, title, etc.).

Define the function as follows:
#+name: elfeed-search-print-entry-function
#+begin_src emacs-lisp :tangle no :noweb yes
(defun +rss/elfeed-search-print-entry (entry)
    "Print ENTRY to the buffer."
    (let* ((elfeed-goodies/tag-column-width 30)
           (elfeed-goodies/feed-source-column-width 30)
           (elfeed-goodies/title-column-width 80) ;; Adjust this width as needed
           (title (or (elfeed-meta entry :title) (elfeed-entry-title entry) ""))
           (title-faces (elfeed-search--faces (elfeed-entry-tags entry)))
           (feed (elfeed-entry-feed entry))
           (feed-title
            (when feed
              (or (elfeed-meta feed :title) (elfeed-feed-title feed))))
           (tags (mapcar #'symbol-name (elfeed-entry-tags entry)))
           (tags-str (concat (mapconcat 'identity tags ",")))
           (title-column (elfeed-format-column
                          title (elfeed-clamp elfeed-goodies/title-column-width
                                              elfeed-goodies/title-column-width
                                              elfeed-goodies/title-column-width)
                          :left))
           (tag-column (elfeed-format-column
                        tags-str (elfeed-clamp (length tags-str)
                                               elfeed-goodies/tag-column-width
                                               elfeed-goodies/tag-column-width)
                        :left))
           (feed-column (elfeed-format-column
                         feed-title (elfeed-clamp elfeed-goodies/feed-source-column-width
                                                  elfeed-goodies/feed-source-column-width
                                                  elfeed-goodies/feed-source-column-width)
                         :left)))

      (insert (propertize feed-column 'face 'elfeed-search-feed-face) " ")
      (insert (propertize title-column 'face title-faces 'kbd-help title) " ")
      (insert (propertize tag-column 'face 'elfeed-search-tag-face))
      (setq-local line-spacing 0.2)))
#+end_src

Then, instruct =elfeed-search= to use the previously defined function as the print-entry function.
#+name:elfeed-search-define-print-entry-function
#+begin_src emacs-lisp :tangle no :noweb yes
(setq elfeed-search-print-entry-function '+rss/elfeed-search-print-entry)
#+end_src

** Minimum title width in search
Define the minimum entry title width in =elfeed-search.= Modify this value if more or less title truncation is desired.

#+name: elfeed-search-title-min-width
#+begin_src emacs-lisp :tangle no :noweb yes
(setq elfeed-search-title-min-width 80)
#+end_src

** Entry switch function
Define how =elfeed= should switch to the feed entry buffer. The options are:

- =switch-to-buffer=: display buffer in the selected window.
- =pop-to-buffer=: display the buffer and select its window.

#+name: elfeed-show-entry-switch
#+begin_src emacs-lisp :tangle no :noweb yes
(setq elfeed-show-entry-switch #'pop-to-buffer)
#+end_src

** Entry delete function
Define how =elfeed= should exit the entry buffer.
#+name: elfeed-show-entry-delete
#+begin_src emacs-lisp :tangle no :noweb yes
(setq elfeed-show-entry-delete #'+rss/delete-pane)
#+end_src

** =elfeed-show= layout
Create a custom function to use as the =elfeed-show-refresh-function= in order to adjust how =elfeed-show= looks.
#+name:elfeed-show-refresh-function
#+begin_src emacs-lisp :tangle no :noweb yes
(defun +rss/elfeed-show-refresh--better-style ()
    "Update the buffer to match the selected entry, using a mail-style."
    (interactive)
    (let* ((inhibit-read-only t)
           (title (elfeed-entry-title elfeed-show-entry))
           (date (seconds-to-time (elfeed-entry-date elfeed-show-entry)))
           (author (elfeed-meta elfeed-show-entry :author))
           (link (elfeed-entry-link elfeed-show-entry))
           (tags (elfeed-entry-tags elfeed-show-entry))
           (tagsstr (mapconcat #'symbol-name tags ", "))
           (nicedate (format-time-string "%a, %e %b %Y %T %Z" date))
           (content (elfeed-deref (elfeed-entry-content elfeed-show-entry)))
           (type (elfeed-entry-content-type elfeed-show-entry))
           (feed (elfeed-entry-feed elfeed-show-entry))
           (feed-title (elfeed-feed-title feed))
           (base (and feed (elfeed-compute-base (elfeed-feed-url feed)))))
      (erase-buffer)
      (insert "\n")
      (insert (format "%s\n\n" (propertize title 'face 'elfeed-show-title-face)))
      (insert (format "%s\t" (propertize feed-title 'face 'elfeed-search-feed-face)))
      (when (and author elfeed-show-entry-author)
        (insert (format "%s\n" (propertize author 'face 'elfeed-show-author-face))))
      (insert (format "%s\n\n" (propertize nicedate 'face 'elfeed-log-date-face)))
      (when tags
        (insert (format "%s\n"
                        (propertize tagsstr 'face 'elfeed-search-tag-face))))
      ;; (insert (propertize "Link: " 'face 'message-header-name))
      ;; (elfeed-insert-link link link)
      ;; (insert "\n")
      (cl-loop for enclosure in (elfeed-entry-enclosures elfeed-show-entry)
               do (insert (propertize "Enclosure: " 'face 'message-header-name))
               do (elfeed-insert-link (car enclosure))
               do (insert "\n"))
      (insert "\n")
      (if content
          (if (eq type 'html)
              (elfeed-insert-html content base)
            (insert content))
        (insert (propertize "(empty)\n" 'face 'italic)))
      (goto-char (point-min))))
#+end_src

Tell =elfeed= to use this function.
#+name:elfeed-show-define-refresh-function
#+begin_src emacs-lisp :tangle no :noweb yes
(setq elfeed-show-refresh-function #'+rss/elfeed-show-refresh--better-style)
#+end_src

** Image size
Define how big images should be displayed relative to the window containing it.
#+name:elfeed-image-size
#+begin_src emacs-lisp :tangle no :noweb yes
(setq shr-max-image-proportion 0.7)
#+end_src

** Better wrap heading
#+name: elfeed-better-wrap-heading
#+begin_src emacs-lisp :tangle no :noweb yes
(defadvice! +rss-elfeed-wrap-h-nicer ()
  "Enhances an elfeed entry's readability by wrapping it to a width of
`fill-column' and centering it with `visual-fill-column-mode'."
  :override #'+rss-elfeed-wrap-h
  (setq-local truncate-lines nil
              shr-width 120
              next-screen-context-lines 4
              visual-fill-column-width 81
              visual-fill-column-center-text t
              default-text-properties '(line-height 1.5))
  (let ((inhibit-read-only t)
        (inhibit-modification-hooks t))
    (visual-fill-column-mode)
    (setq-local shr-current-font '(:family "Lato" :weight 'medium :height 1.5))
    (set-buffer-modified-p nil)))
#+end_src

** Capture to Org-roam
#+begin_src emacs-lisp
(defun dysthesis/elfeed-capture-entry ()
  (interactive)
  ;; Check if we are in elfeed-show-mode
  (if (eq major-mode 'elfeed-show-mode)
      (let* ((entry elfeed-show-entry)  ; Get the current entry in elfeed-show
             (link (elfeed-entry-link entry))
             (title (elfeed-entry-title entry)))
        ;; Initiate an Org-roam capture
        (org-roam-capture- :keys "e" :node (org-roam-node-create :title title))
        (insert link))  ; Insert only the URL
    (message "Not in elfeed-show mode!")))
#+end_src
** Miscellaneous
#+begin_src emacs-lisp
(after! elfeed-search
  (set-evil-initial-state! 'elfeed-search-mode 'normal))
(after! elfeed-show-mode
  (set-evil-initial-state! 'elfeed-show-mode   'normal))

(after! evil-snipe
  (push 'elfeed-show-mode   evil-snipe-disabled-modes)
  (push 'elfeed-search-mode evil-snipe-disabled-modes))

(bind-key "C-c e" #'elfeed)
#+end_src
** Keybindings
#+begin_src emacs-lisp
(map! :map elfeed-search-mode-map
      :after elfeed-search
      [remap kill-this-buffer] "q"
      [remap kill-buffer] "q"
      :n doom-leader-key nil
      :n "q" #'+rss/quit
      :n "e" #'elfeed-update
      :n "r" #'elfeed-search-untag-all-unread
      :n "u" #'elfeed-search-tag-all-unread
      :n "s" #'elfeed-search-live-filter
      :n "RET" #'elfeed-search-show-entry
      :n "p" #'elfeed-show-pdf
      :n "+" #'elfeed-search-tag-all
      :n "-" #'elfeed-search-untag-all
      :n "S" #'elfeed-search-set-filter
      :n "b" #'elfeed-search-browse-url
      :n "y" #'elfeed-search-yank)
(map! :map elfeed-show-mode-map
      :after elfeed-show
      [remap kill-this-buffer] "q"
      [remap kill-buffer] "q"
      :n doom-leader-key nil
      :nm "q" #'+rss/delete-pane
      :nm "o" #'ace-link-elfeed
      :nm "RET" #'org-ref-elfeed-add
      :nm "n" #'elfeed-show-next
      :nm "N" #'elfeed-show-prev
      :nm "p" #'elfeed-show-pdf
      :nm "c" #'dysthesis/elfeed-capture-entry
      :nm "r" #'elfeed-show-refresh
      :nm "+" #'elfeed-show-tag
      :nm "-" #'elfeed-show-untag
      :nm "s" #'elfeed-show-new-live-search
      :nm "y" #'elfeed-show-yank)
#+end_src

* Citations
The =biblio= module on Doom Emacs provides support for bibliography and citations, via Citar.

** Citar
This is the core of the =biblio= module provided by Doom Emacs.
#+begin_src emacs-lisp :noweb yes
(use-package citar
  :custom
  <<citar-bib-path>>
  :hook
  <<citar-hooks>>)
#+end_src

*** Bibliography file
Direct Citar to the =.bib= file where the bibliography is stored.
#+name:citar-bib-path
#+begin_src emacs-lisp :noweb yes :tangle no
(citar-bibliography '("~/Org/Library.bib"))
#+end_src

*** Hooks
Define the modes for which Citar should be initialised, namely Org-mode and LaTeX-mode.
#+name:citar-hooks
#+begin_src emacs-lisp :noweb yes :tangle no
(LaTeX-mode . citar-capf-setup)
(org-mode . citar-capf-setup)
#+end_src

*** Note opening function
#+begin_src emacs-lisp
(defun my-citar-org-open-notes (key entry)
  (let* ((bib (string-join (list my/bibtex-directory key ".bib")))
         (org (string-join (list my/bibtex-directory key ".org")))
         (new (not (file-exists-p org))))
    (funcall citar-file-open-function org)
    (when (and new (eq (buffer-size) 0))
      (insert (format template
                      (assoc-default "title" entry)
                      user-full-name
                      user-mail-address
                      bib
                      (with-temp-buffer
                        (insert-file-contents bib)
                        (buffer-string))))
      (search-backward "|")
      (delete-char 1))))

(setq-default citar-open-note-function 'my-citar-org-open-notes)
#+end_src

*** Keybindings
#+begin_src emacs-lisp
(bind-key "C-c o" #'citar-open)
#+end_src

** =oc-csl-activate=
#+begin_src emacs-lisp
(use-package! oc-csl-activate
  :after oc
  :config
  (setq org-cite-csl-activate-use-document-style t)
  (defun +org-cite-csl-activate/enable ()
    (interactive)
    (setq org-cite-activate-processor 'csl-activate)
    (add-hook! 'org-mode-hook '((lambda () (cursor-sensor-mode 1)) org-cite-csl-activate-render-all))
    (defadvice! +org-cite-csl-activate-render-all-silent (orig-fn)
      :around #'org-cite-csl-activate-render-all
      (with-silent-modifications (funcall orig-fn)))
    (when (eq major-mode 'org-mode)
      (with-silent-modifications
        (save-excursion
          (goto-char (point-min))
          (org-cite-activate (point-max)))
        (org-cite-csl-activate-render-all)))
    (fmakunbound #'+org-cite-csl-activate/enable)))
#+end_src

* LaTeX
* Development
** LSP
*** LSP-UI
#+begin_src emacs-lisp
(after! lsp-ui
  (setq lsp-ui-doc-enable t
        lsp-ui-sideline-show-diagnostics t
        lsp-ui-sideline-show-hover t
        lsp-ui-sideline-show-code-actions t))
#+end_src
** Nix
This is of critical importance, as NixOS is my primary operating system.

*** Alejandra
Alejandra provides better formatting than nixfmt, in my opinion. Get nix-mode to use it as a formatter.
#+begin_src emacs-lisp
(set-formatter! 'alejandra "alejandra --quiet" :modes '(nix-mode))
(after! apheleia
  (push '(alejandra . ("alejandra" "-")) apheleia-formatters)
  (setf (alist-get 'nix apheleia-mode-alist) 'alejandra))
#+end_src
*Source:* https://github.com/kamadorueda/alejandra/blob/main/integrations/doom-emacs/README.md

* LLM
[[https://github.com/karthink/gptel][gptel]] allows for Emacs to act as a frontend for OLLaMa.

#+begin_src emacs-lisp
;; OPTIONAL configuration
(setq-default gptel-model "deepseek-coder:6.7b" ;Pick your default model
              gptel-backend (gptel-make-ollama "Ollama"             ;Any name of your choosing
                              :host "localhost:11434"               ;Where it's running
                              :stream t                             ;Stream responses
                              :models '("deepseek-coder:6.7b"
                                        "deepseek-coder:33b"
                                        "dolphin-mixtral:latest")))         ;List of models
#+end_src

* Miscellaneous
** Default shell
#+begin_src emacs-lisp
(setq-default shell-file-name (executable-find "dash"))
#+end_src
